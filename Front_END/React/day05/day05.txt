---------------------------------------------------

* HOOK 함수

react에서 상태 변경, 즉 가상돔의 상태를 변경할 수 있는 함수
그에 따른 생명 주기를 통해 다양한 이벤트를 실행할 수 있는 함수

react 초기 상태
class형 컴포넌트를 사용

const 컴포넌트명 = () =>{
}

class 컴포넌트명 extends components{
    ...
}
라이프 사이클
[페이지가 처음 열렸을 때 ~ 페이지가 닫혔을 때까지]
이 사이에 일어나는 이벤트나 값 변경 등을 관리 

Class는 다양한 기능을 사용할 수 있지만 기계와 사용자를 혼동시킨다.
숙련된 react 개발자 조차도 Class를 통한 React의 완벽한 이해는 힘들다.

==> 함수형으로 리액트를 만들어보자 -> 함수형 컴포넌트의 등장
==> 자연스럽게 생명주기(라이프 사이클)이 사라지고 Hook 함수가 등장하였다.


---------------------------------------------------

1. useState
- Hooks의 상태 관리 함수
- 값이 바뀐 것을 감지하여 리랜더링
- 값이 바뀌는 것을 감지하여 리랜더링 시켜줘야할 필요가 있을 때 사용하는 변수

2. useRef
- js에서 getElemntByid, querySelector와 같은 DOM SELECTOR 함수 처럼
- React에서 DOM에 접근하게 되는 일이 생긴다면 접근하게 해주는 함수
- ref 객체 내부의 값은 render와 상관없이 유지된다

---------------------------------------------------

* state 불변성, spread operator

---------------------------------------------------

3. useMemo
    연산된 (결과)를 반환히여 랜더링 되었을 때 재사용할 수 있도록 해주는 Hooks 함수

4. useCallback
    특정 함수를 새로 만들지 않고 랜더링 되었을 때 재사용할 수 있게 해주는 Hooks 함수

Q. useMemo useCallback을 사용해서 최적화를 진행한다고 했을 때 
어떤 부분에서 최적화(전방면)가 가능할까요?

* 메모이제이션
- 어떤 함수가 생성되거나 해당 값이 연산되는 결과가 오래걸린다 (30초)
- 리엑트는 상태가 바뀌면 랜더링, 따라서 해당 함수나 값도 랜더링 시 재실행 
- 그런데? 값이 바뀌지 않는 부분이 랜더링 되어야할 필요가 없음
- 즉 값이 안바뀌는 연산, 재선언 해야할 필요가 없는 함수를 랜더링이 되더라도
- 재생성 및 연산하지 않도록 (랜더링 시 필요 없는 연산이나 시간을 줄여주기 위해)하기 위해 사용

5. useEffect
- 마운트 / 언마운트 시 특정 작업(함수,이벤트)를 실행할 때 사용하는 hook함수
- 의존성 배열의 값이 바뀌었을 때 역시 함수나 이벤트를 실행

* 마운트 : 화면 처음 랜더링
* 언마운트 : 화면이 사라질 때