


                    1000 = 1초
setTimeout(콜백함수, 밀리초)        : 넘겨준 함수를 해당 밀리초만큼 흐른 뒤 호출
clearTimeout(설정된 타임아웃 객체)  : setTimeout에서 설정된 것을 취소

setInterval(콜백함수, 밀리초)       : 넘겨준 함수를 해당 밀리초마다 흐른 뒤 호출
clearInterval(설정된 인터벌 객체)   : setInterval에서 설정된 것을 취소

-------------------------------------------------------------------------

콜백 함수(callback function)
매개변수로 함수를 전달받아서 함수 내부에서 그 함수를 실행하는 경우


ex)

const print = () => {
    console.log("print")
}

setTimeout(print, 3000)
            함수를

setTimeout(() => {
    console.log("print")
}, 3000)

--------------------------------------------------------------------------

callback 지옥

    JS는 비동기를 마주하는 상황이 빈번하게 일어남

    동기적인 흐름
    : 동기는 요청을 보낸 후 결과물을 받아야 다음 동작이 이루어지는 방식

    비동기적인 흐름
    : 효율성을 위해 비동기는 요청을 보낸 후 결과를 받지 않아도 다음 동작이 이루어지는 방식

    // 비동기 통신중에서도 데이터를 받아오기전에 실행하면 안되는 코드가 있을 때
    ex)
    블로그
    게시글 번호, 댓글 내용을 벡엔드서버로 보내면

    벡엔드 서버는 
    해당 게시글 번호 게시글의 정보를 데이터베이스(데이터저장소)에서 찾아냄 --(비동기ing)
    그리고 해당 게시글 정보에 맞는 댓글에 데이터를 추가함.

    이 경우 게시글을 찾기도 전에 댓글 데이터에 추가하면? ---> 에러 

    비동기를 동기적인 흐름으로 만들어줄 필요가 있음
    ===> 게시글을 먼저 찾고 나서 댓글 추가 해 

    이러한 비동기의 동기적 흐름 처리를 위하여 콜백함수를 많이 사용하는데
    이런 콜백함수가 중첩되어 함수의 길이가 깊어지고 가독성이 떨어지며 코드가 난잡해 보이는 형상 
    ===> 콜백지옥 현상

    해결방안 
    기명함수 ====> 한계 
    promise, async, await  == 비동기를 동기적을 처리하기 위해 


----------ES6

promise
    비동기 통신 상황일 때 악명 높은 콜백지옥을 탈출했다는 점에서 높은 평가
    대기 이행 실패 상태가 존재하며 각 pending, resolve, reject라고 칭함.

    promise를 선언하면 대기상태에서 실행은 되어있지만 
    나중에 어떠한 조건을 만족했을 때 결과값을 받는 객체

async, await
    promise의 then catch의 반복으로 인한 코드가 길어지는 현상과 pending(대기) 상태가 지속되는 
    현상을 해결하기 위해 등장 


--------------------------------------------------------------------------